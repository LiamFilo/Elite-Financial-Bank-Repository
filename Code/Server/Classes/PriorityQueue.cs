///////////////////////////////////////////////////////////
//  PriorityQueue.cs
//  Implementation of the Class PriorityQueue
//  Generated by Enterprise Architect
//  Created on:      28-ιπε-2025 22:32:06
//  Original author: pilol
///////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Text;
using System.IO;



using Server;
using Server.Classes;
using BankingEnumeration;
using System.Globalization;
namespace Server {
	public class PriorityQueue
	{
        private readonly SortedDictionary<RequestPriority, Queue<Request>> priorityQueue;
        private readonly object _lock = new object(); // Thread safety lock
        public Server.CommandProcessingViewModel m_CommandProcessingViewModel;

        public PriorityQueue()
		{
            priorityQueue = new SortedDictionary<RequestPriority, Queue<Request>>();
            foreach (RequestPriority priority in Enum.GetValues(typeof(RequestPriority)))
            {
                priorityQueue[priority] = new Queue<Request>();
            }
        }

        /// <summary>
        /// Adds a new request to the queue based on its priority.
        /// </summary>
        public void Enqueue(Request request)
        {

            RequestPriority priority = request.Priority;

            lock (_lock) // Thread-safe operation
            {
                priorityQueue[priority].Enqueue(request);
            }
            Console.WriteLine($"Request {request.CommandToExecute.CommandType} added with priority {priority}");
        }

        /// <summary>
        /// Removes and returns the highest-priority request.
        /// </summary>
        public Request Dequeue()
        {
            lock (_lock)
            {
                foreach (var priorityLevel in priorityQueue.Keys.OrderBy(p => p))
                {
                    if (priorityQueue[priorityLevel].Count > 0)
                    {
                        Request request = priorityQueue[priorityLevel].Dequeue();
                        Console.WriteLine($"Dequeued {request.c} with priority {priorityLevel}");
                        return request;
                    }
                }
            }
            throw new InvalidOperationException("Queue is empty.");
        }

        /// <summary>
        /// Checks if the queue is empty.
        /// </summary>
        public bool IsEmptyQueue()
        {
            lock (_lock)
            {
                return priorityQueue.Values.All(q => q.Count == 0);
            }
        }

        /// <summary>
        /// Processes the next request in the queue.
        /// </summary>
        public void ProcessNextRequest()
        {
            if (IsEmptyQueue())
            {
                Console.WriteLine("No requests to process.");
                return;
            }

            Request request = Dequeue();
            Console.WriteLine($"Processing: {request.CommandType}");

            // Add logic for handling request here
        }

        /// <summary>
        /// Assigns priority based on the command type.
        /// </summary>
        public static RequestPriority SetPriorityQueue(ClientCommandType commandType)
        {
            switch (commandType)
            {
                case ClientCommandType.Log_In:
                    return RequestPriority.High;
                case ClientCommandType.Log_Out:
                    return RequestPriority.Medium;
                default:
                    throw new ArgumentException($"Unhandled client command type: {commandType}");
            }
        }



        public static RequestPriority SetPriorityQueue(ClientCommandType commandType)
		{
			switch (commandType)
			{
				case (ClientCommandType.Log_In):
					break;
				case (ClientCommandType.Log_Out): 
					break;
			}
            throw new ArgumentException("Set Priority Queue func dont handle this client command type");
        }

	}


}